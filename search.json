[{"path":"https://kwb-r.github.io/kwb.raindrop/articles/workflow.html","id":"define-paths-and-scenarios","dir":"Articles","previous_headings":"","what":"Define Paths and Scenarios","title":"Workflow","text":"","code":"library(kwb.raindrop)  path_list <- list(   root_path = \"C:/kwb/projects/raindrop/01102025_Raindrop_Daten\",   dir_base = \"<root_path>/Optimierungsfall\",   dir_exe = \"<root_path>/Berechnungskern\",   dir_input = \"<root_path>/Optimierungsfall/models/input\",   dir_output = \"<root_path>/Optimierungsfall/models/output\",    dir_target_output = \"<dir_output>/<dir_target>\",   file_base = \"Optimierungsfall_kurz.h5\",   file_errors_hdf5 = \"Fehlerprotokoll.h5\",   file_exe = \"Regenwasserbewirtschaftung.exe\",   file_results_hdf5 = \"Optimierung_MuldenRigole.h5\",   file_results_txt = \"Optimierung_MuldenRigole_RAINDROP.txt\",    file_results_txt_multilayer = \"Optimierung_MuldenRigole_RAINDROP_multi_layer.txt\",    file_target = \"<dir_target>.h5\",   path_base = \"<dir_base>/<file_base>\",   path_exe = \"<dir_exe>/<file_exe>\",   path_errors_hdf5 = \"<dir_target_output>/<file_errors_hdf5>\",   path_results_hdf5 = \"<dir_target_output>/<file_results_hdf5>\",   path_results_txt = \"<dir_target_output>/<file_results_txt>\",    path_results_txt_multilayer = \"<dir_target_output>/<file_results_txt_multilayer>\",    path_target_input = \"<dir_input>/<file_target>\",   path_target_output = \"<dir_output>/<file_target>\" )   parameters <- tibble::tibble(   para_nama_short = c(\"mulde_area\",                      \"mulde_height\",                     \"filter_hydraulicconductivity\",                     \"filter_height\",                     \"storage_height\",                     \"bottom_hydraulicconductivity\"                     ),   para_name_long = c(\"/Massnahmenelemente/Optimierung_MuldenRigole/Allgemein/Flaeche\",                    \"/Massnahmenelemente/Optimierung_MuldenRigole/Eigenschaften_Oberflaeche/Ueberlaufhoehe\",                    \"Bodenarten/Bodenfilter/Ks_HydraulicConductivity\",                    \"/Massnahmenelemente/Optimierung_MuldenRigole/Bodenschichtung/Schichtdicken\",                    \"/Massnahmenelemente/Optimierung_MuldenRigole/Bodenschichtung/Schichtdicken\",                    \"/Massnahmenelemente/Optimierung_MuldenRigole/Allgemein/Endversickerungsrate\"                    ),   index = c(1L,             1L,             1L,             1L,             2L,             1L) )  DT::datatable(parameters) mulde_area <- c(1,10,50,100,500,1000) mulde_height <- 1:5 * 100 filter_hydraulicconductivity <- c(10,20,45,90,180,270,360) filter_height <- c(200, 400, 600) storage_height <- c(150, 300, 600, 900, 1200) rain_factor <- c(1,2,3) bottom_hydraulicconductivity <- c(1,5,10,20,45,90,180,270,360,1860,3600)   # Alle Kombinationen erzeugen param_grid_all_combinations <- expand.grid(   mulde_area = mulde_area,   mulde_height = mulde_height,   filter_hydraulicconductivity = filter_hydraulicconductivity,   filter_height = filter_height,   storage_height = storage_height,   bottom_hydraulicconductivity = bottom_hydraulicconductivity,   rain_factor = rain_factor )  param_grid_all_combinations <- param_grid_all_combinations %>%    dplyr::bind_cols(tibble::tibble(scenario_name = sprintf(\"s%05d\",                                                            seq_len(nrow(param_grid_all_combinations)))))  ref_scenario <- param_grid_all_combinations %>%         dplyr::filter(mulde_area == 100,                       filter_hydraulicconductivity == 90,                       bottom_hydraulicconductivity == 20,                       mulde_height == 300,                      filter_height == 200,                      storage_height == 150,                      rain_factor == 3) %>%         dplyr::pull(scenario_name)  stopifnot(length(ref_scenario)==1)  scenarios_with_single_parameter_variation <- kwb.raindrop::find_single_param_variations(   data = param_grid_all_combinations,   ref_scenario = ref_scenario   ) %>%    dplyr::pull(scenario_name) %>% unique() #> Rows with exactly one differing parameter: 33 of 103950 #> Single-parameter variations per parameter: mulde_area=5, mulde_height=4, filter_hydraulicconductivity=6, filter_height=2, storage_height=4, bottom_hydraulicconductivity=10, rain_factor=2  param_grid <- param_grid_all_combinations  %>%    dplyr::filter(scenario_name %in% scenarios_with_single_parameter_variation)  DT::datatable(param_grid)"},{"path":"https://kwb-r.github.io/kwb.raindrop/articles/workflow.html","id":"run-model","dir":"Articles","previous_headings":"","what":"Run Model","title":"Workflow","text":"","code":"# Number of cores for parallel processing (or: automatic) #future::plan(future::multisession, workers = parallel::detectCores() - 1)  lapply(seq_len(nrow(param_grid)), function(i) {      param_grid_tmp <- param_grid[i, ]      paths <- kwb.utils::resolve(path_list, dir_target = param_grid_tmp$scenario_name)      fs::dir_create(paths$dir_input)   fs::dir_create(paths$dir_output)   fs::dir_create(paths$dir_target_output)      fs::file_copy(path = paths$path_base,                  new_path = paths$path_target_input,                  overwrite = TRUE)      # \"a\" = read/write (legt an, falls nicht da); alternativ \"r+\" = read/write, aber nicht neu anlegen   h5 <- hdf5r::H5File$new(paths$path_target_input, mode = \"a\")       new_path <- stringr::str_c(normalizePath(fs::path_abs(paths$dir_target_output)),                               \"\\\\\")     # 2) Alle Werte lesen (als named list, Keys = absolute Pfade) vals <- kwb.raindrop::h5_read_values(h5)  vals$`//Berechnungsparameter/Ergebnispfad` <- new_path vals$`//Massnahmenelemente/Optimierung_MuldenRigole/Allgemein/Flaeche` <- param_grid_tmp$mulde_area vals$`//Massnahmenelemente/Optimierung_MuldenRigole/Eigenschaften_Oberflaeche/Ueberlaufhoehe` <-  param_grid_tmp$mulde_height vals$`//Bodenarten/Bodenfilter/Ks_HydraulicConductivity` <- param_grid_tmp$filter_hydraulicconductivity vals$`//Massnahmenelemente/Optimierung_MuldenRigole/Bodenschichtung/Schichtdicken`[1] <- param_grid_tmp$filter_height  vals$`//Massnahmenelemente/Optimierung_MuldenRigole/Bodenschichtung/Schichtdicken`[2] <- param_grid_tmp$storage_height vals$`//Massnahmenelemente/Optimierung_MuldenRigole/Allgemein/Endversickerungsrate` <- param_grid_tmp$bottom_hydraulicconductivity  # Timeseries (2×N) als tibble? if (is.data.frame(vals[[\"//Regen/Regenganglinie\"]])) {   vals[[\"//Regen/Regenganglinie\"]]$value <- vals[[\"//Regen/Regenganglinie\"]]$value * param_grid_tmp$rain_factor }  # 3) Schreiben mit safe-Fallback für echte SCALAR-Fälle kwb.raindrop::h5_write_values(h5, vals, resize = TRUE, scalar_strategy = \"error\", verbose = FALSE) h5$close_all()      kwb.raindrop::run_model(path_exe = paths$path_exe,                           path_input = paths$path_target_input) })   ### Read results for first run  paths <- kwb.utils::resolve(path_list, dir_target = sprintf(\"s%05d\", i = 1))  simulation_names <- basename(fs::dir_ls(paths$dir_output)) simulation_names <- scenarios_with_single_parameter_variation  debug <- TRUE errors_df <- lapply(simulation_names, function(s_name) {      s_id <- s_name %>% stringr::str_remove(\"s\") %>%  as.integer()   paths <- kwb.utils::resolve(path_list, dir_target = s_name, i = s_id)      if(fs::file_exists(paths$path_errors_hdf5)) {     kwb.utils::catAndRun(messageText = sprintf(\"Reading error file '%s'\",                                                paths$path_errors_hdf5),                          expr = {     error_hdf <- hdf5r::H5File$new(paths$path_errors_hdf5, mode = \"r\")          tibble::tibble(id = s_id,                     path = paths$path_errors_hdf5,                    number_of_errors = error_hdf[[\"AnzahlFehler\"]]$read()     )                          },     dbg = debug)   } }) %>%    dplyr::bind_rows()"},{"path":"https://kwb-r.github.io/kwb.raindrop/articles/workflow.html","id":"analyse-results","dir":"Articles","previous_headings":"","what":"Analyse Results","title":"Workflow","text":"","code":"import_results_from_rds <- FALSE debug <- TRUE paths <- kwb.utils::resolve(path_list, dir_target = sprintf(\"s%05d\", i = 1))  simulation_names <- basename(fs::dir_ls(paths$dir_output)) simulation_names <- scenarios_with_single_parameter_variation  simulation_results <- if(import_results_from_rds == FALSE) {   stats::setNames(lapply(simulation_names, function(s_name) {   s_id <- s_name %>% stringr::str_remove(\"s\") %>%  as.integer()  if(file.exists(paths$path_results_hdf5)) { paths <- kwb.utils::resolve(path_list, dir_target = s_name, i = s_id)      kwb.utils::catAndRun(messageText = sprintf(\"Reading results file '%s'\",                                                paths$path_results_hdf5),                          expr = {  # \"a\" = read/write (legt an, falls nicht da); alternativ \"r+\" = read/write, aber nicht neu anlegen res_hdf5 <- hdf5r::H5File$new(paths$path_results_hdf5, mode = \"r\")  hdf5_results <- list(   rates = kwb.raindrop::read_hdf5_timeseries(res_hdf5[[\"Raten\"]]),   additional_evapotranspiration = kwb.raindrop::read_hdf5_timeseries(res_hdf5[[\"Zusaetzliche Variablen Evapotranspiration\"]]),   additional_infiltration = kwb.raindrop::read_hdf5_timeseries(res_hdf5[[\"Zusaetzliche Variablen Infiltration\"]]),   states = kwb.raindrop::read_hdf5_timeseries(res_hdf5[[\"Zustandsvariablen\"]]) )  hdf5_results },  dbg = debug)}}), nm = simulation_names) } else {   readRDS(file = \"../simulation_results.Rds\") }   pdff <- \"simulation_results_per_scenario_rain-factor_3-2.pdf\" kwb.utils::preparePdf(pdff) lapply(scenarios_with_single_parameter_variation, function(s_name) {  selected_scenario <- param_grid %>%    dplyr::filter(scenario_name == s_name)  simulation_results[[s_name]]$states %>%    dplyr::bind_rows(simulation_results[[s_name]]$rates) %>%    dplyr::filter(variable %in% c(\"h_pond\",                                  \"fPI_InfiltrationRate\",                                 \"fPI_InfiltrationRate_deeperLayers\",                                  \"f_Endversickerungsrate\")) %>%    ggplot2::ggplot(ggplot2::aes(x = time, y = value)) +   ggplot2::geom_point() +   ggplot2::facet_wrap(~ variable, nrow = 2, ncol = 2) +   ggplot2::labs(title = sprintf(\"Scenario ID: %s\",                                  s_name),                 subtitle = sprintf(\"mulde: area %d m2, height: %d mm; filter: kf: %d mm/h, height: %d mm; storage_height: %d mm, bottom_kf: %.2f mm/h; rain_factor: %.2f\",                                  selected_scenario$mulde_area,                                 selected_scenario$mulde_height,                                  selected_scenario$filter_hydraulicconductivity,                                  selected_scenario$filter_height,                                  selected_scenario$storage_height,                                  selected_scenario$bottom_hydraulicconductivity,                                  selected_scenario$rain_factor)) +   ggplot2::theme_bw() }) kwb.utils::finishAndShowPdf(pdff)   simulation_results_h_pond_list <- stats::setNames(lapply(names(simulation_results), function(s_name) {    simulation_results[[s_name]]$states %>%    dplyr::filter(variable == \"h_pond\") %>%    dplyr::summarise(h_pond_max = max(value),                     h_pond_mean = mean(value))  }), names(simulation_results))   simulation_results_h_pond <- simulation_results_h_pond_list %>%    dplyr::bind_rows(, .id = \"scenario_name\") %>%    dplyr::left_join(param_grid,                    by = \"scenario_name\")    ### Plot results  pdff <- \"simulation_results_h_pond_max_rain-factor_3-2.pdf\" kwb.utils::preparePdf(pdff) kwb.raindrop::plot_hpond_vs_ref(data = simulation_results_h_pond,                                 response = \"h_pond_max\",                                 ref_scenario = ref_scenario,                                 diff = \"abs\") kwb.utils::finishAndShowPdf(pdff)  pdff <- \"simulation_results_h_pond_mean_rain-factor_3-2.pdf\" kwb.utils::preparePdf(pdff) kwb.raindrop::plot_hpond_vs_ref(data = simulation_results_h_pond,                                 response = \"h_pond_mean\",                                 ref_scenario = ref_scenario,                                 diff = \"abs\") kwb.utils::finishAndShowPdf(pdff)"},{"path":"https://kwb-r.github.io/kwb.raindrop/articles/workflow_v2.html","id":"define-paths-and-scenarios","dir":"Articles","previous_headings":"","what":"Define Paths and Scenarios","title":"Workflow V2","text":"","code":"library(kwb.raindrop)  path_list <- list(   root_path = \"C:/kwb/projects/raindrop/2025-12-11_Raindrop_Daten\",   dir_base = \"<root_path>/Optimierungsfall\",   dir_exe = \"<root_path>/Berechnungskern\",   dir_input = \"<root_path>/Optimierungsfall/models/input\",   dir_output = \"<root_path>/Optimierungsfall/models/output\",    dir_target_output = \"<dir_output>/<dir_target>\",   file_base = \"FlaecheUndMassnahmenelement.h5\",   file_errors_hdf5 = \"Fehlerprotokoll.h5\",   file_exe = \"Regenwasserbewirtschaftung.exe\",   file_results_hdf5_element = \"Element_1.h5\",   file_results_hdf5_flaeche = \"Flaeche_1.h5\",   file_results_hdf5_verschaltungen = \"<dir_target>_Verschaltungen.h5\",   file_results_txt = \"Element_1_RAINDROP.txt\",    file_results_txt_multilayer = \"Element_1_RAINDROP_multi_layer.txt\",    file_target = \"<dir_target>.h5\",   path_base = \"<dir_base>/<file_base>\",   path_exe = \"<dir_exe>/<file_exe>\",   path_errors_hdf5 = \"<dir_target_output>/<file_errors_hdf5>\",   path_results_hdf5_element = \"<dir_target_output>/<file_results_hdf5_element>\",   path_results_hdf5_flaeche = \"<dir_target_output>/<file_results_hdf5_flaeche>\",   path_results_hdf5_verschaltungen = \"<dir_target_output>/<file_results_hdf5_verschaltungen>\",   path_results_txt = \"<dir_target_output>/<file_results_txt>\",    path_results_txt_multilayer = \"<dir_target_output>/<file_results_txt_multilayer>\",    path_target_input = \"<dir_input>/<file_target>\" )   parameters <- tibble::tibble(   para_nama_short = c(\"connected_area\",                      \"mulde_area\",                      \"mulde_height\",                     \"filter_hydraulicconductivity\",                     \"filter_height\",                     \"storage_height\",                     \"bottom_hydraulicconductivity\"                     ),   para_name_long = c(                    \"/Massnahmenelemente/Flaeche_1/Allgemein/Flaeche\",                    \"/Massnahmenelemente/Element_1/Allgemein/Flaeche\",                    \"/Massnahmenelemente/Element_1/Eigenschaften_Oberflaeche/Ueberlaufhoehe\",                    \"Bodenarten/Bodenfilter/Ks_HydraulicConductivity\",                    \"/Massnahmenelemente/Element_1/Bodenschichtung/Schichtdicken\",                    \"/Massnahmenelemente/Element_1/Bodenschichtung/Schichtdicken\",                    \"/Massnahmenelemente/Element_1/Allgemein/Endversickerungsrate\"                    ),   index = c(1L,             1L,             1L,             1L,             1L,             2L,             1L) )  DT::datatable(parameters) connected_area <- c(1,10,50,100,500,1000) mulde_area <- c(1,10,50,100,500,1000) mulde_height <- 1:5 * 100 filter_hydraulicconductivity <- c(10,20,45,90,180,270,360) filter_height <- c(200, 400, 600) storage_height <- c(150, 300, 600, 900, 1200) rain_factor <- c(1,2,3) bottom_hydraulicconductivity <- c(1,5,10,20,45,90,180,270,360,1860,3600)   # Alle Kombinationen erzeugen param_grid_all_combinations <- expand.grid(   connected_area = connected_area,   mulde_area = mulde_area,   mulde_height = mulde_height,   filter_hydraulicconductivity = filter_hydraulicconductivity,   filter_height = filter_height,   storage_height = storage_height,   bottom_hydraulicconductivity = bottom_hydraulicconductivity,   rain_factor = rain_factor )  param_grid_all_combinations <- param_grid_all_combinations %>%    dplyr::bind_cols(tibble::tibble(scenario_name = sprintf(\"s%05d\",                                                            seq_len(nrow(param_grid_all_combinations)))))  ref_scenario <- param_grid_all_combinations %>%         dplyr::filter(connected_area == 1,                      mulde_area == 1,                       filter_hydraulicconductivity == 90,                       bottom_hydraulicconductivity == 20,                       mulde_height == 300,                      filter_height == 200,                      storage_height == 150,                      rain_factor == 3) %>%         dplyr::pull(scenario_name)  stopifnot(length(ref_scenario)==1)  scenarios_with_single_parameter_variation <- kwb.raindrop::find_single_param_variations(   data = param_grid_all_combinations,   ref_scenario = ref_scenario   ) %>%    dplyr::pull(scenario_name) %>% unique() #> Rows with exactly one differing parameter: 38 of 623700 #> Single-parameter variations per parameter: connected_area=5, mulde_area=5, mulde_height=4, filter_hydraulicconductivity=6, filter_height=2, storage_height=4, bottom_hydraulicconductivity=10, rain_factor=2  param_grid <- param_grid_all_combinations  %>%    dplyr::filter(scenario_name %in% scenarios_with_single_parameter_variation)  DT::datatable(param_grid)"},{"path":"https://kwb-r.github.io/kwb.raindrop/articles/workflow_v2.html","id":"run-model","dir":"Articles","previous_headings":"","what":"Run Model","title":"Workflow V2","text":"","code":"# Number of cores for parallel processing (or: automatic) #future::plan(future::multisession, workers = parallel::detectCores() - 1)  lapply(seq_len(nrow(param_grid)), function(i) {      param_grid_tmp <- param_grid[i, ]      paths <- kwb.utils::resolve(path_list, dir_target = param_grid_tmp$scenario_name)      fs::dir_create(paths$dir_input)   fs::dir_create(paths$dir_output)   fs::dir_create(paths$dir_target_output)      fs::file_copy(path = paths$path_base,                  new_path = paths$path_target_input,                  overwrite = TRUE)      # \"a\" = read/write (legt an, falls nicht da); alternativ \"r+\" = read/write, aber nicht neu anlegen   h5 <- hdf5r::H5File$new(paths$path_target_input, mode = \"a\")       new_path <- stringr::str_c(normalizePath(fs::path_abs(paths$dir_target_output)),                               \"\\\\\")     # 2) Alle Werte lesen (als named list, Keys = absolute Pfade) vals <- kwb.raindrop::h5_read_values(h5)  vals$`//Berechnungsparameter/Ergebnispfad` <- new_path vals$`//Massnahmenelemente/Flaeche_1/Allgemein/Flaeche` <- param_grid_tmp$connected_area vals$`//Massnahmenelemente/Element_1/Allgemein/Flaeche` <- param_grid_tmp$mulde_area vals$`//Massnahmenelemente/Element_1/Eigenschaften_Oberflaeche/Ueberlaufhoehe` <-  param_grid_tmp$mulde_height vals$`//Bodenarten/Bodenfilter/Ks_HydraulicConductivity` <- param_grid_tmp$filter_hydraulicconductivity vals$`//Massnahmenelemente/Element_1/Bodenschichtung/Schichtdicken`[1] <- param_grid_tmp$filter_height  vals$`//Massnahmenelemente/Element_1/Bodenschichtung/Schichtdicken`[2] <- param_grid_tmp$storage_height vals$`//Massnahmenelemente/Element_1/Allgemein/Endversickerungsrate` <- param_grid_tmp$bottom_hydraulicconductivity  # Timeseries (2×N) als tibble? if (is.data.frame(vals[[\"//Kurven/Regen\"]])) {   vals[[\"//Kurven/Regen\"]]$value <- vals[[\"//Kurven/Regen\"]]$value * param_grid_tmp$rain_factor }  # 3) Schreiben mit safe-Fallback für echte SCALAR-Fälle kwb.raindrop::h5_write_values(h5, vals, resize = TRUE, scalar_strategy = \"error\", verbose = FALSE) h5$close_all()      kwb.raindrop::run_model(path_exe = paths$path_exe,                           path_input = paths$path_target_input) })   ### Read results for first run  paths <- kwb.utils::resolve(path_list, dir_target = sprintf(\"s%05d\", i = 1))  simulation_names <- basename(fs::dir_ls(paths$dir_output)) simulation_names <- scenarios_with_single_parameter_variation  debug <- TRUE errors_df <- lapply(simulation_names, function(s_name) {      s_id <- s_name %>% stringr::str_remove(\"s\") %>%  as.integer()   paths <- kwb.utils::resolve(path_list, dir_target = s_name, i = s_id)      if(fs::file_exists(paths$path_errors_hdf5)) {     kwb.utils::catAndRun(messageText = sprintf(\"Reading error file '%s'\",                                                paths$path_errors_hdf5),                          expr = {     error_hdf <- hdf5r::H5File$new(paths$path_errors_hdf5, mode = \"r\")          tibble::tibble(id = s_id,                     path = paths$path_errors_hdf5,                    number_of_errors = error_hdf[[\"AnzahlFehler\"]]$read()     )                          },     dbg = debug)   } }) %>%    dplyr::bind_rows()"},{"path":"https://kwb-r.github.io/kwb.raindrop/articles/workflow_v2.html","id":"analyse-results","dir":"Articles","previous_headings":"","what":"Analyse Results","title":"Workflow V2","text":"","code":"import_results_from_rds <- FALSE debug <- TRUE paths <- kwb.utils::resolve(path_list, dir_target = sprintf(\"s%05d\", i = 1))  simulation_names <- basename(fs::dir_ls(paths$dir_output)) simulation_names <- scenarios_with_single_parameter_variation  simulation_results <- if(import_results_from_rds == FALSE) {   stats::setNames(lapply(simulation_names, function(s_name) {   s_id <- s_name %>% stringr::str_remove(\"s\") %>%  as.integer()  paths <- kwb.utils::resolve(path_list, dir_target = s_name, i = s_id)  if(all(file.exists(c(paths$path_results_hdf5_verschaltungen,                   paths$path_results_hdf5_element,                   paths$path_results_hdf5_flaeche)))) {      kwb.utils::catAndRun(messageText = sprintf(\"Reading results file '%s'\",                                                paths$path_results_hdf5),                          expr = {  # \"a\" = read/write (legt an, falls nicht da); alternativ \"r+\" = read/write, aber nicht neu anlegen res_hdf5_element <- hdf5r::H5File$new(paths$path_results_hdf5_element, mode = \"r\") res_hdf5_flaeche <- hdf5r::H5File$new(paths$path_results_hdf5_flaeche, mode = \"r\") res_hdf5_verschaltungen <- hdf5r::H5File$new(paths$path_results_hdf5_verschaltungen, mode = \"r\")  hdf5_results <- list(   element = list(     meta = kwb.raindrop::read_hdf5_scalars(res_hdf5_element[[\"Metainfo\"]], numeric_only = FALSE),     rates = kwb.raindrop::read_hdf5_timeseries(res_hdf5_element[[\"Raten\"]]),     water_balance = kwb.raindrop::read_hdf5_scalars(res_hdf5_element[[\"Wasserbilanz\"]]),     additional_evapotranspiration = kwb.raindrop::read_hdf5_timeseries(res_hdf5_element[[\"Zusaetzliche Variablen Evapotranspiration\"]]),     additional_infiltration = kwb.raindrop::read_hdf5_timeseries(res_hdf5_element[[\"Zusaetzliche Variablen Infiltration\"]]),     states = kwb.raindrop::read_hdf5_timeseries(res_hdf5_element[[\"Zustandsvariablen\"]])),   connected_area = list(     meta = kwb.raindrop::read_hdf5_scalars(res_hdf5_flaeche[[\"Metainfo\"]], numeric_only = FALSE),     rates = kwb.raindrop::read_hdf5_timeseries(res_hdf5_flaeche[[\"Raten\"]]),     water_balance = kwb.raindrop::read_hdf5_scalars(res_hdf5_flaeche[[\"Wasserbilanz\"]]),     additional_evapotranspiration = kwb.raindrop::read_hdf5_timeseries(res_hdf5_flaeche[[\"Zusaetzliche Variablen Evapotranspiration\"]]),     additional_infiltration = kwb.raindrop::read_hdf5_timeseries(res_hdf5_flaeche[[\"Zusaetzliche Variablen Infiltration\"]]),     states = kwb.raindrop::read_hdf5_timeseries(res_hdf5_flaeche[[\"Zustandsvariablen\"]])),   connections =  kwb.raindrop::read_hdf5_connections(res_hdf5_verschaltungen)   )  hdf5_results },  dbg = debug)}}), nm = simulation_names) } else {   readRDS(file = \"../simulation_results.Rds\") }   pdff <- \"simulation_results_per_scenario_v2.pdf\" kwb.utils::preparePdf(pdff) lapply(scenarios_with_single_parameter_variation, function(s_name) {  selected_scenario <- param_grid %>%    dplyr::filter(scenario_name == s_name)  simulation_results[[s_name]]$element$states %>%    dplyr::bind_rows(simulation_results[[s_name]]$element$rates) %>%    dplyr::filter(variable %in% c(\"h_pond\",                                  \"fPI_InfiltrationRate\",                                 #\"fPI_InfiltrationRate_deeperLayers\",                                  \"f_Endversickerungsrate\")) %>%    ggplot2::ggplot(ggplot2::aes(x = time, y = value)) +   ggplot2::geom_point() +   ggplot2::facet_wrap(~ variable, nrow = 2, ncol = 2, scales = \"free_y\") +   ggplot2::labs(title = sprintf(\"Scenario ID: %s\",                                  s_name),                 subtitle = sprintf(\"connected area: %d m2, mulde: area %d m2, height: %d mm; filter: kf: %d mm/h, height: %d mm; storage_height: %d mm, bottom_kf: %.2f mm/h; rain_factor: %.2f\",                                  selected_scenario$connected_area,                                 selected_scenario$mulde_area,                                 selected_scenario$mulde_height,                                  selected_scenario$filter_hydraulicconductivity,                                  selected_scenario$filter_height,                                  selected_scenario$storage_height,                                  selected_scenario$bottom_hydraulicconductivity,                                  selected_scenario$rain_factor)) +   ggplot2::theme_bw() }) kwb.utils::finishAndShowPdf(pdff)   simulation_results_h_pond_list <- stats::setNames(lapply(names(simulation_results), function(s_name) {    simulation_results[[s_name]]$element$states %>%    dplyr::filter(variable == \"h_pond\") %>%    dplyr::summarise(h_pond_max = max(value),                     h_pond_mean = mean(value))  }), names(simulation_results))   simulation_results_h_pond <- simulation_results_h_pond_list %>%    dplyr::bind_rows(, .id = \"scenario_name\") %>%    dplyr::left_join(param_grid,                    by = \"scenario_name\")    ### Plot results  pdff <- \"simulation_results_h_pond_max_v2.pdf\" kwb.utils::preparePdf(pdff) kwb.raindrop::plot_hpond_vs_ref(data = simulation_results_h_pond,                                 response = \"h_pond_max\",                                 ref_scenario = ref_scenario,                                 diff = \"abs\") kwb.utils::finishAndShowPdf(pdff)  pdff <- \"simulation_results_h_pond_mean_v2.pdf\" kwb.utils::preparePdf(pdff) kwb.raindrop::plot_hpond_vs_ref(data = simulation_results_h_pond,                                 response = \"h_pond_mean\",                                 ref_scenario = ref_scenario,                                 diff = \"abs\") kwb.utils::finishAndShowPdf(pdff)"},{"path":"https://kwb-r.github.io/kwb.raindrop/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michael Rustler. Author, maintainer. RAINDROP. Funder. . Copyright holder.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Rustler M (2025). kwb.raindrop: R Package Optimisation Simulations Rainwater Management Simulations Performed Calculation Engine Provided Tandler. R package version 0.0.0.9000, https://github.com/KWB-R/kwb.raindrop.","code":"@Manual{,   title = {kwb.raindrop: R Package for Optimisation Simulations for Rainwater Management Simulations Performed with Calculation Engine Provided by Tandler},   author = {Michael Rustler},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://github.com/KWB-R/kwb.raindrop}, }"},{"path":"https://kwb-r.github.io/kwb.raindrop/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"R Package for Optimisation Simulations for Rainwater Management Simulations Performed with Calculation Engine Provided by Tandler","text":"details install KWB-R packages checkout installation tutorial.","code":"### Optionally: specify GitHub Personal Access Token (GITHUB_PAT) ### See here why this might be important for you: ### https://kwb-r.github.io/kwb.pkgbuild/articles/install.html#set-your-github_pat  # Sys.setenv(GITHUB_PAT = \"mysecret_access_token\")  # Install package \"remotes\" from CRAN if (! require(\"remotes\")) {   install.packages(\"remotes\", repos = \"https://cloud.r-project.org\") }  # Install KWB package 'kwb.raindrop' from GitHub remotes::install_github(\"KWB-R/kwb.raindrop\")"},{"path":"https://kwb-r.github.io/kwb.raindrop/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Kompetenzzentrum Wasser Berlin gGmbH (KWB) Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/find_single_param_variations.html","id":null,"dir":"Reference","previous_headings":"","what":"Find scenarios that differ from a reference in exactly one parameter — find_single_param_variations","title":"Find scenarios that differ from a reference in exactly one parameter — find_single_param_variations","text":"Identifies rows differ reference exactly one parameter. may pass param_cols explicitly, let function infer excluding id_col, exclude_cols, columns matching exclude_cols_regex (default excludes result columns like h_*).","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/find_single_param_variations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find scenarios that differ from a reference in exactly one parameter — find_single_param_variations","text":"","code":"find_single_param_variations(   data,   ref_scenario = \"s00001\",   id_col = \"scenario_name\",   param_cols = NULL,   exclude_cols = NULL,   exclude_cols_regex = \"^h_\",   tol = 1e-09,   quiet = FALSE,   include_reference = c(\"per_param\", \"none\") )"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/find_single_param_variations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find scenarios that differ from a reference in exactly one parameter — find_single_param_variations","text":"data data frame scenarios. ref_scenario Reference scenario ID (default \"s00001\"). id_col Name scenario ID column (default \"scenario_name\"). param_cols Optional character vector parameter columns. NULL, parameters inferred. exclude_cols Character vector exclude parameter detection. exclude_cols_regex Regex auto-exclude non-parameter columns (default \"^h_\"). tol Numeric tolerance numeric comparisons (default 1e-9). quiet Logical; print diagnostics FALSE (default). include_reference \"per_param\" (default) include one reference row per parameter hits, \"none\".","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/find_single_param_variations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find scenarios that differ from a reference in exactly one parameter — find_single_param_variations","text":"data frame columns: id_col, param_name, param_value, is_reference. Attributes: \"param_cols\", \"ref_row\", \"diff_mat\", \"n_diff\".","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_read_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Read values of all (or selected) datasets — h5_read_values","title":"Read values of all (or selected) datasets — h5_read_values","text":"Read values (selected) datasets","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_read_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read values of all (or selected) datasets — h5_read_values","text":"","code":"h5_read_values(   h5,   paths = NULL,   simplify_scalars = TRUE,   timeseries_as_tibble = TRUE,   ts_names = c(\"time\", \"value\") )"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_read_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read values of all (or selected) datasets — h5_read_values","text":"h5 open hdf5r::H5File paths character vector; NULL read simplify_scalars logical: simplify H5S_SCALAR length-1 atom timeseries_as_tibble logical: convert 2xN / Nx2 tibble(time,value) ts_names character(2): names time/value columns","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_read_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read values of all (or selected) datasets — h5_read_values","text":"named list","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_validate_write.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate what would be written where (pre-flight check) — h5_validate_write","title":"Validate what would be written where (pre-flight check) — h5_validate_write","text":"Checks named list values open HDF5 file summarizes, per dataset path, current dimensions (fallback via h5$ls()), length/column count supplied value, suggested handling (SCALAR/1D/ND TS(2-col) 2-column time series).","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_validate_write.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate what would be written where (pre-flight check) — h5_validate_write","text":"","code":"h5_validate_write(h5, values)"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_validate_write.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate what would be written where (pre-flight check) — h5_validate_write","text":"h5 open hdf5r::H5File (e.g., opened mode = \"r+\"). values named list. Names absolute dataset paths (starting \"/\"); values R objects written (scalar, vector, matrix/array, 2-column data.frame/tibble time series).","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_validate_write.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate what would be written where (pre-flight check) — h5_validate_write","text":"tibble columns: path – dataset path (normalizing \"//\" → \"/\"). cur_dims – detected dims \"2x4\" \"SCALAR\". val_len – length supplied value (data frames: nrow). df_cols – number columns (data frames/tibbles; otherwise NA). decision – heuristic label: \"SCALAR\", \"1D\", \"ND\", \"TS(2-col)\". note – additional note (e.g., \"found\").","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_validate_write.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate what would be written where (pre-flight check) — h5_validate_write","text":"get_simple_extent_dims() incorrectly reports dataset SCALAR, function falls back dimensions derived list_h5_datasets(h5) (.e., h5$ls(recursive = TRUE)). Names values normalized multiple leading slashes collapse single leading slash.","code":""},{"path":[]},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_validate_write.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate what would be written where (pre-flight check) — h5_validate_write","text":"","code":"if (FALSE) { # \\dontrun{ library(hdf5r) h5 <- H5File$new(\"input.h5\", mode = \"r+\")  vals <- list(   \"/Parameters/OutputPath\" = \"C:/temp/out.h5\",   \"/Rain/Hyetograph\" = tibble::tibble(time = c(0, 10, 20, 30),                                       value = c(0, 5, 12, 0)),   \"/Measures/.../LayerThickness\" = c(150L, 150L) )  h5_validate_write(h5, vals) } # }"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_write_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Write (updated) values back into existing HDF5 datasets (robust) — h5_write_values","title":"Write (updated) values back into existing HDF5 datasets (robust) — h5_write_values","text":"Writes scalars, vectors, matrices/arrays, 2-column data frames/tibbles (treated time series) existing HDF5 datasets. dataset reports SCALAR incorrectly, function can infer target dimensions supplied value resize accordingly.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_write_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write (updated) values back into existing HDF5 datasets (robust) — h5_write_values","text":"","code":"h5_write_values(   h5,   values,   resize = TRUE,   strict = TRUE,   prefer_rows = NA,   ts_cols = c(\"time\", \"value\"),   scalar_strategy = c(\"error\", \"first\", \"collapse\"),   collapse_sep = \";\",   verbose = FALSE )"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_write_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write (updated) values back into existing HDF5 datasets (robust) — h5_write_values","text":"h5 open hdf5r::H5File (e.g., mode = \"r+\"). values Named list: names absolute dataset paths, values R objects write. resize Logical. TRUE, resize datasets via set_extent() shapes differ. strict Logical. TRUE, stop first error; otherwise warn skip. prefer_rows Logical(1) NA. 2-column time series: NA keeps dataset orientation (2xN first dim == 2), TRUE forces 2xN, FALSE forces Nx2. ts_cols Character(2). Column names pull time-series data frames (default c(\"time\",\"value\")). scalar_strategy One \"error\", \"first\", \"collapse\". Controls non-length-1 values handled true SCALAR datasets. collapse_sep Character. Separator used scalar_strategy = \"collapse\". verbose Logical. TRUE, prints per-path dimension info.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_write_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write (updated) values back into existing HDF5 datasets (robust) — h5_write_values","text":"Invisibly returns character vector written dataset paths.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/h5_write_values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write (updated) values back into existing HDF5 datasets (robust) — h5_write_values","text":"","code":"if (FALSE) { # \\dontrun{ vals <- h5_read_values(h5) vals[[\"/Parameters/OutputPath\"]] <- \"C:/temp/out.h5\" h5_write_values(h5, vals, resize = TRUE, scalar_strategy = \"first\", verbose = TRUE) } # }"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/list_h5_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"List all datasets (recursive) — list_h5_datasets","title":"List all datasets (recursive) — list_h5_datasets","text":"List datasets (recursive)","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/list_h5_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List all datasets (recursive) — list_h5_datasets","text":"","code":"list_h5_datasets(h5)"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/list_h5_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List all datasets (recursive) — list_h5_datasets","text":"h5 open hdf5r::H5File.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/list_h5_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List all datasets (recursive) — list_h5_datasets","text":"tibble columns: path, obj_type, dims, maxdims.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/list_h5_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List all datasets (recursive) — list_h5_datasets","text":"","code":"if (FALSE) { # \\dontrun{ h5 <- hdf5r::H5File$new(\"file.h5\", mode = \"r\") list_h5_datasets(h5) } # }"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/plot_hpond_vs_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the influence of single-parameter variations on a response — plot_hpond_vs_ref","title":"Plot the influence of single-parameter variations on a response — plot_hpond_vs_ref","text":"Uses find_single_param_variations() (default excluding ^h_ columns parameter detection) plots absolute percentage deviations chosen response. title shows reference value mm.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/plot_hpond_vs_ref.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the influence of single-parameter variations on a response — plot_hpond_vs_ref","text":"","code":"plot_hpond_vs_ref(   data,   response,   ref_scenario = \"s00001\",   diff = c(\"abs\", \"pct\"),   param_cols = NULL,   exclude_cols = NULL,   exclude_cols_regex = \"^h_\",   tol = 1e-09,   quiet = FALSE )"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/plot_hpond_vs_ref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the influence of single-parameter variations on a response — plot_hpond_vs_ref","text":"data Data frame least scenario_name, parameter columns, response. response Character; response column plot (e.g. \"h_pond_max\" \"h_pond_mean\"). ref_scenario Reference scenario ID (default \"s00001\"). diff \"abs\" absolute \"pct\" percentage deviation. param_cols Optional explicit parameter columns (recommended prefilter). exclude_cols Extra columns exclude parameter detection. exclude_cols_regex Regex auto-exclude non-parameter columns (default \"^h_\"). tol Numeric tolerance passed find_single_param_variations(). quiet Logical; diagnostics FALSE.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/plot_hpond_vs_ref.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the influence of single-parameter variations on a response — plot_hpond_vs_ref","text":"ggplot object.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_connections.html","id":null,"dir":"Reference","previous_headings":"","what":"Read surface-water connections from an HDF5 results file — read_hdf5_connections","title":"Read surface-water connections from an HDF5 results file — read_hdf5_connections","text":"Reads HDF5 file contains surface-water connections (formerly \"Verschaltungen\"), e.g. file like s78853_Verschaltungen.h5. file expected : root-level scalar dataset \"Anzahl Verschaltungen\", one group per connection (\"0\", \"1\", ...) contains scalar metadata (e.g. von_Layer, von_Massnahmenelement, nach_Layer, nach_Massnahmenelement) time-series datasets stored 2×N matrices (e.g. Qtatsaechlich, delta_h_pond_*, delta_theta_*). Scalar metadata returned als breite Tabelle (meta), als lange Tabelle (scalars) und pro Verbindung einer Unterliste (connections$group_0, ...). Time series werden Long-Format zurückgegeben und mit den Metadaten verknüpft.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_connections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read surface-water connections from an HDF5 results file — read_hdf5_connections","text":"","code":"read_hdf5_connections(file)"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_connections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read surface-water connections from an HDF5 results file — read_hdf5_connections","text":"file hdf5r::H5File object pointing *_Verschaltungen.h5 file, already opened read mode.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_connections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read surface-water connections from an HDF5 results file — read_hdf5_connections","text":"named list components: n_connections integer(1). Value root dataset \"Anzahl Verschaltungen\" (NA_integer_ present). meta tibble one row per connection: connection_id, from_layer, from_element, to_layer, to_element. timeseries tibble long-format time series connections: connection_id, variable, time, value, from_layer, from_element, to_layer, to_element. scalars tibble scalar datasets per connection long format: connection_id, variable, value (list), type. connections named list per-connection sublists: connections$group_0, connections$group_1, ...; containing connection_id, meta, timeseries, scalars für genau diese Verbindung.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_connections.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read surface-water connections from an HDF5 results file — read_hdf5_connections","text":"","code":"if (FALSE) { # \\dontrun{   library(hdf5r)    f <- H5File$new(paths$path_verschaltungen_hdf5, mode = \"r\")   conn <- read_hdf5_connections(f)    conn$n_connections   conn$meta   conn$timeseries    # Unterliste für die erste Verbindung:   conn$connections$group_0$meta   conn$connections$group_0$timeseries } # }"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_scalars.html","id":null,"dir":"Reference","previous_headings":"","what":"Read scalar datasets from an HDF5 group — read_hdf5_scalars","title":"Read scalar datasets from an HDF5 group — read_hdf5_scalars","text":"Reads scalar datasets contained HDF5 group returns tibble. default, numeric / integer scalars returned. non-numeric scalars (e.g. strings) present, can either dropped warning kept list-column.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_scalars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read scalar datasets from an HDF5 group — read_hdf5_scalars","text":"","code":"read_hdf5_scalars(group, numeric_only = TRUE)"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_scalars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read scalar datasets from an HDF5 group — read_hdf5_scalars","text":"group hdf5r::H5Group object. Direct children group expected scalar datasets (.e. dataset.dims == 0). numeric_only Logical (default: TRUE). TRUE, numeric / integer scalars returned (others dropped warning). FALSE, scalars returned list-column value together type column.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_scalars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read scalar datasets from an HDF5 group — read_hdf5_scalars","text":"numeric_only = TRUE: tibble columns variable character. Dataset name within group. value numeric. Scalar value read dataset. numeric_only = FALSE: tibble columns variable character. Dataset name within group. value list. Scalar values (numeric, integer, character, ...). type character. First class value (e.g. \"numeric\", \"character\").","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_scalars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read scalar datasets from an HDF5 group — read_hdf5_scalars","text":"","code":"if (FALSE) { # \\dontrun{   # Wasserbilanz: nur numerische Skalare   wb_tbl <- read_hdf5_scalars(res_hdf5_element[[\"Wasserbilanz\"]])    # Metainfo: gemischte Typen (Integer + String)   meta_tbl <- read_hdf5_scalars(res_hdf5_element[[\"Metainfo\"]],                                 numeric_only = FALSE) } # }"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_timeseries.html","id":null,"dir":"Reference","previous_headings":"","what":"Read HDF5 Results Time Series from HDF5 Group into a Long Tibble — read_hdf5_timeseries","title":"Read HDF5 Results Time Series from HDF5 Group into a Long Tibble — read_hdf5_timeseries","text":"Extracts datasets (subgroups) given HDF5 group converts 2×N numeric matrix tidy long table. assumes first row holds time/index vector second row values. Datasets 2×N numeric matrices (e.g. scalar metadata like von_Layer, von_Massnahmenelement, ...) silently ignored.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_timeseries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read HDF5 Results Time Series from HDF5 Group into a Long Tibble — read_hdf5_timeseries","text":"","code":"read_hdf5_timeseries(ts_groupvariable)"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_timeseries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read HDF5 Results Time Series from HDF5 Group into a Long Tibble — read_hdf5_timeseries","text":"ts_groupvariable hdf5r::H5Group open HDF5 group whose time-series children stored 2×N numeric matrices ([1, ] = time/index, [2, ] = value), possibly mixed scalar metadata datasets.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/read_hdf5_timeseries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read HDF5 Results Time Series from HDF5 Group into a Long Tibble — read_hdf5_timeseries","text":"tibble columns: variable (character): dataset name within group. time     (numeric): time index taken first row. value    (numeric): values taken second row.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/run_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Run an rainwater management model executable with an input file — run_model","title":"Run an rainwater management model executable with an input file — run_model","text":"Builds runs system command form \"<path_exe> <path_input>\", normalising paths absolute paths. Progress (optionally) command output wrapped kwb.utils::catAndRun() neat logging.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/run_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run an rainwater management model executable with an input file — run_model","text":"","code":"run_model(path_exe, path_input, print_output = FALSE, debug = TRUE, ...)"},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/run_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run an rainwater management model executable with an input file — run_model","text":"path_exe character(1) Path model executable (e.g., .exe Windows). file must exist. path_input character(1) Path model input file passed single argument executable. file must exist. print_output logical(1) TRUE, stream process output console return exit status (integer). FALSE (default), capture return command output character vector. debug logical(1) Forwarded kwb.utils::catAndRun(dbg = ...) enable/disable progress message. Default: TRUE. ... Additional arguments passed base::shell(), e.g. timeout Windows. See ?base::shell details.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/run_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run an rainwater management model executable with an input file — run_model","text":"print_output = FALSE, character vector containing captured standard output command. print_output = TRUE, (invisible) integer exit status returned shell() (0 indicates success).","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/run_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run an rainwater management model executable with an input file — run_model","text":"path_exe path_input converted absolute, normalised paths via fs::path_abs() base::normalizePath(). command executed base::shell(), Windows invokes system shell. non-Windows platforms, prefer base::system() need full POSIX semantics.","code":""},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/run_model.html","id":"side-effects","dir":"Reference","previous_headings":"","what":"Side effects","title":"Run an rainwater management model executable with an input file — run_model","text":"Executes external program may read/write files depending model. Ensure trust executable paths provided.","code":""},{"path":[]},{"path":"https://kwb-r.github.io/kwb.raindrop/reference/run_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run an rainwater management model executable with an input file — run_model","text":"","code":"if (FALSE) { # \\dontrun{ # Example: run a hypothetical model with an input file exe   <- \"C:/path/to/model.exe\" input <- \"C:/path/to/input.h5\"  # Capture output as character vector out <- run_model(exe, input, print_output = FALSE)  # Stream output and get exit status status <- run_model(exe, input, print_output = TRUE) } # }"},{"path":"https://kwb-r.github.io/kwb.raindrop/news/index.html","id":"kwbraindrop-0009000","dir":"Changelog","previous_headings":"","what":"kwb.raindrop 0.0.0.9000","title":"kwb.raindrop 0.0.0.9000","text":"Added NEWS.md file track changes package. see https://style.tidyverse.org/news.html writing good NEWS.md","code":""}]
